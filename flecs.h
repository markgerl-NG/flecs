#define flecs_STATIC

#ifndef FLECS_H
#define FLECS_H

// #define FLECS_LEGACY         /* Define for C89 support */
// #define FLECS_CUSTOM_BUILD   /* Define for customizing a build */

/**
 * @file api_defines.h
 * @brief Supporting defines for the public API.
 *
 * This file contains constants / macro's that are typically not used by an
 * application but support the public API, and therefore must be exposed. This
 * header should not be included by itself.
 */

#ifndef FLECS_API_DEFINES_H
#define FLECS_API_DEFINES_H

/* Standard library dependencies */
#include <time.h>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

/* Non-standard but required. If not provided by platform, add manually. */
#include <stdint.h>

/* Contains macro's for importing / exporting symbols */
/*
                                   )
                                  (.)
                                  .|.
                                  | |
                              _.--| |--._
                           .-';  ;`-'& ; `&.
                          \   &  ;    &   &_/
                           |"""---...---"""|
                           \ | | | | | | | /
                            `---.|.|.|.---'

 * This file is generated by bake.lang.c for your convenience. Headers of
 * dependencies will automatically show up in this file. Include bake_config.h
 * in your main project file. Do not edit! */

#ifndef FLECS_BAKE_CONFIG_H
#define FLECS_BAKE_CONFIG_H

/* Headers of public dependencies */
/* No dependencies */

/* Convenience macro for exporting symbols */
#ifndef flecs_STATIC
#if flecs_APIS && (defined(_MSC_VER) || defined(__MINGW32__))
  #define FLECS_API __declspec(dllexport)
#elif flecs_APIS
  #define FLECS_API __attribute__((__visibility__("default")))
#elif defined _MSC_VER
  #define FLECS_API __declspec(dllimport)
#else
  #define FLECS_API
#endif
#else
  #define FLECS_API
#endif

#endif


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Language support defines
////////////////////////////////////////////////////////////////////////////////

#ifndef FLECS_LEGACY
#include <stdbool.h>
#endif

/* The API uses the native bool type in C++, or a custom one in C */
#if !defined(__cplusplus) && !defined(__bool_true_false_are_defined)
#undef bool
#undef true
#undef false
typedef char bool;
#define false 0
#define true !false
#endif

typedef uint32_t ecs_flags32_t;
typedef uint64_t ecs_flags64_t;

/* Keep unsigned integers out of the codebase as they do more harm than good */
typedef int32_t ecs_size_t;

/** This reserves entity ids for components. Regular entity ids will start after
 * this constant. This affects performance of table traversal, as edges with ids 
 * lower than this constant are looked up in an array, whereas constants higher
 * than this id are looked up in a map. Increasing this value can improve
 * performance at the cost of (significantly) higher memory usage. */
#define ECS_HI_COMPONENT_ID (256) /* Maximum number of components */


////////////////////////////////////////////////////////////////////////////////
//// Reserved ids
////////////////////////////////////////////////////////////////////////////////

/* Builtin component ids */
#define FLECS__EEcsComponent (1)
#define FLECS__EEcsName (2)

/* Builtin tag ids */
#define EcsModule (ECS_HI_COMPONENT_ID + 0)
#define EcsDisabled (ECS_HI_COMPONENT_ID + 1)
#define EcsWildcard (ECS_HI_COMPONENT_ID + 2)

/* Builtin roles */
#define EcsScope (ECS_HI_COMPONENT_ID + 3)

/* Builtin module ids */
#define EcsFlecs (ECS_HI_COMPONENT_ID + 4)
#define EcsFlecsCore (ECS_HI_COMPONENT_ID + 5)

/* Value used to quickly check if component is builtin. This is used to quickly
 * filter out tables with builtin components (for example for ecs_delete) */
#define EcsLastInternalComponentId (ecs_typeid(EcsName))

/* The first user-defined component starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserComponentId (32)

/* The first user-defined entity starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserEntityId (ECS_HI_COMPONENT_ID + 32)


////////////////////////////////////////////////////////////////////////////////
//// Entity id macro's
////////////////////////////////////////////////////////////////////////////////

#define ECS_ENTITY_MASK       ((uint64_t)0xFFFFFFFF)
#define ECS_GENERATION_MASK   ((uint64_t)0xFFFF << 32)
#define ECS_GENERATION(e)     ((e & ECS_GENERATION_MASK) >> 32)
#define ECS_GENERATION_INC(e) ((e & ~ECS_GENERATION_MASK) | ((ECS_GENERATION(e) + 1) << 32))
#define ECS_COMPONENT_MASK    ((ecs_entity_t)~ECS_ROLE_MASK)


////////////////////////////////////////////////////////////////////////////////
//// Utilities for working with trait identifiers
////////////////////////////////////////////////////////////////////////////////

#define ecs_entity_t_lo(value) ((uint32_t)(value))
#define ecs_entity_t_hi(value) ((uint32_t)((value) >> 32))
#define ecs_entity_t_comb(v1, v2) (((uint64_t)(v2) << 32) + (uint32_t)(v1))


////////////////////////////////////////////////////////////////////////////////
//// Error codes
////////////////////////////////////////////////////////////////////////////////

#define ECS_INTERNAL_ERROR (1)
#define ECS_INVALID_OPERATION (2)
#define ECS_INVALID_PARAMETER (3)
#define ECS_INVALID_ID (4)
#define ECS_INVALID_COMPONENT (5)
#define ECS_OUT_OF_MEMORY (6)
#define ECS_MISSING_OS_API (7)
#define ECS_INCONSISTENT_COMPONENT_ACTION (8)
#define ECS_INVALID_FROM_WORKER (9)


////////////////////////////////////////////////////////////////////////////////
//// Utilities
////////////////////////////////////////////////////////////////////////////////

#define ECS_OFFSET(o, offset) (void*)(((uintptr_t)(o)) + ((uintptr_t)(offset)))
#define ECS_SIZEOF(T) (ecs_size_t)sizeof(T)
#define ECS_ALIGN(size, alignment) (ecs_size_t)((((((size_t)size) - 1) / ((size_t)alignment)) + 1) * ((size_t)alignment))
#define ECS_MAX(a, b) ((a > b) ? a : b)

/* Use alignof in C++, or a trick in C. */
#ifdef __cplusplus
#define ECS_ALIGNOF(T) (int64_t)alignof(T)
#elif defined(_MSC_VER)
#define ECS_ALIGNOF(T) (int64_t)__alignof(T)
#elif defined(__GNUC__)
#define ECS_ALIGNOF(T) (int64_t)__alignof__(T)
#else
#define ECS_ALIGNOF(T) ((int64_t)&((struct { char c; T d; } *)0)->d)
#endif

#if defined(__GNUC__)
#define ECS_UNUSED __attribute__((unused))
#else
#define ECS_UNUSED
#endif

#ifdef __cplusplus
}
#endif

#endif

typedef uint64_t ecs_entity_t;
typedef struct ecs_world_t ecs_world_t;

#ifndef FLECS_VECTOR_H
#define FLECS_VECTOR_H


#ifdef __cplusplus
extern "C" {
#endif

/* Public, so we can do compile-time offset calculation */
struct ecs_vector_t {
    int32_t count;
    int32_t size;
    
#ifndef NDEBUG
    int64_t elem_size;
#endif
};

#define ECS_VECTOR_U(size, alignment) size, ECS_MAX(ECS_SIZEOF(ecs_vector_t), alignment)
#define ECS_VECTOR_T(T) ECS_VECTOR_U(ECS_SIZEOF(T), ECS_ALIGNOF(T))

typedef struct ecs_vector_t ecs_vector_t;

typedef int (*ecs_comparator_t)(
    const void* p1,
    const void *p2);

FLECS_API ecs_vector_t* _ecs_vector_new(
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_new(T, elem_count) \
    _ecs_vector_new(ECS_VECTOR_T(T), elem_count)

#define ecs_vector_new_t(size, alignment, elem_count) \
    _ecs_vector_new(ECS_VECTOR_U(size, alignment), elem_count)    

FLECS_API ecs_vector_t* _ecs_vector_from_array(
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count,
    void *array);

#define ecs_vector_from_array(T, elem_count, array)\
    _ecs_vector_from_array(ECS_VECTOR_T(T), elem_count, array)

FLECS_API void _ecs_vector_zero(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_zero(vector, T) \
    _ecs_vector_zero(vector, ECS_VECTOR_T(T))

FLECS_API void ecs_vector_free(
    ecs_vector_t *vector);

FLECS_API void ecs_vector_clear(
    ecs_vector_t *vector);

FLECS_API void ecs_vector_assert_size(
    ecs_vector_t* vector_inout,
    ecs_size_t elem_size);

FLECS_API void ecs_vector_assert_alignment(
    ecs_vector_t* vector,
    ecs_size_t elem_alignment);    

FLECS_API void* _ecs_vector_add(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_add(vector, T) \
    ((T*)_ecs_vector_add(vector, ECS_VECTOR_T(T)))

#define ecs_vector_add_t(vector, size, alignment) \
    _ecs_vector_add(vector, ECS_VECTOR_U(size, alignment))

FLECS_API void* _ecs_vector_addn(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_addn(vector, T, elem_count) \
    ((T*)_ecs_vector_addn(vector, ECS_VECTOR_T(T), elem_count))

#define ecs_vector_addn_t(vector, size, alignment, elem_count) \
    _ecs_vector_addn(vector, ECS_VECTOR_U(size, alignment), elem_count)

FLECS_API void* _ecs_vector_get(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_vector_get(vector, T, index) \
    ((T*)_ecs_vector_get(vector, ECS_VECTOR_T(T), index))

#define ecs_vector_get_t(vector, size, alignment, index) \
    _ecs_vector_get(vector, ECS_VECTOR_U(size, alignment), index)

FLECS_API void* _ecs_vector_last(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_last(vector, T) \
    (T*)_ecs_vector_last(vector, ECS_VECTOR_T(T))

FLECS_API int32_t _ecs_vector_set_min_size(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_min_size(vector, T, size) \
    _ecs_vector_set_min_size(vector, ECS_VECTOR_T(T), size)

FLECS_API int32_t _ecs_vector_set_min_count(
    ecs_vector_t **vector_inout,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_min_count(vector, T, size) \
    _ecs_vector_set_min_count(vector, ECS_VECTOR_T(T), size)

FLECS_API void ecs_vector_remove_last(
    ecs_vector_t *vector);

FLECS_API bool _ecs_vector_pop(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    void *value);

#define ecs_vector_pop(vector, T, value) \
    _ecs_vector_pop(vector, ECS_VECTOR_T(T), value)

FLECS_API int32_t _ecs_vector_move_index(
    ecs_vector_t **dst,
    ecs_vector_t *src,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_vector_move_index(dst, src, T, index) \
    _ecs_vector_move_index(dst, src, ECS_VECTOR_T(T), index)

FLECS_API int32_t _ecs_vector_remove_index(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_vector_remove_index(vector, T, index) \
    _ecs_vector_remove_index(vector, ECS_VECTOR_T(T), index)

#define ecs_vector_remove_index_t(vector, size, alignment, index) \
    _ecs_vector_remove_index(vector, ECS_VECTOR_U(size, alignment), index)

FLECS_API void _ecs_vector_reclaim(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_reclaim(vector, T)\
    _ecs_vector_reclaim(vector, ECS_VECTOR_T(T))

FLECS_API int32_t _ecs_vector_grow(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_grow(vector, T, size) \
    _ecs_vector_grow(vector, ECS_VECTOR_T(T), size)

FLECS_API int32_t _ecs_vector_set_size(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_size(vector, T, elem_count) \
    _ecs_vector_set_size(vector, ECS_VECTOR_T(T), elem_count)

#define ecs_vector_set_size_t(vector, size, alignment, elem_count) \
    _ecs_vector_set_size(vector, ECS_VECTOR_U(size, alignment), elem_count)

FLECS_API int32_t _ecs_vector_set_count(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_count(vector, T, elem_count) \
    _ecs_vector_set_count(vector, ECS_VECTOR_T(T), elem_count)

#define ecs_vector_set_count_t(vector, size, alignment, elem_count) \
    _ecs_vector_set_count(vector, ECS_VECTOR_U(size, alignment), elem_count)

FLECS_API int32_t ecs_vector_count(
    const ecs_vector_t *vector);

FLECS_API int32_t ecs_vector_size(
    const ecs_vector_t *vector);

FLECS_API void* _ecs_vector_first(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_first(vector, T) \
    ((T*)_ecs_vector_first(vector, ECS_VECTOR_T(T)))

#define ecs_vector_first_t(vector, size, alignment) \
    _ecs_vector_first(vector, ECS_VECTOR_U(size, alignment))

FLECS_API void _ecs_vector_sort(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    ecs_comparator_t compare_action);

#define ecs_vector_sort(vector, T, compare_action) \
    _ecs_vector_sort(vector, ECS_VECTOR_T(T), compare_action)

FLECS_API void _ecs_vector_memory(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t *allocd,
    int32_t *used);

#define ecs_vector_memory(vector, T, allocd, used) \
    _ecs_vector_memory(vector, ECS_VECTOR_T(T), allocd, used)

#define ecs_vector_memory_t(vector, size, alignment, allocd, used) \
    _ecs_vector_memory(vector, ECS_VECTOR_U(size, alignment), allocd, used)

FLECS_API ecs_vector_t* _ecs_vector_copy(
    const ecs_vector_t *src,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_copy(src, T) \
    _ecs_vector_copy(src, ECS_VECTOR_T(T))

#define ecs_vector_copy_t(src, size, alignment) \
    _ecs_vector_copy(src, ECS_VECTOR_U(size, alignment))

#ifndef FLECS_LEGACY
#define ecs_vector_each(vector, T, var, ...)\
    {\
        int var##_i, var##_count = ecs_vector_count(vector);\
        T* var##_array = ecs_vector_first(vector, T);\
        for (var##_i = 0; var##_i < var##_count; var##_i ++) {\
            T* var = &var##_array[var##_i];\
            __VA_ARGS__\
        }\
    }
#endif

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_SPARSE_H
#define FLECS_SPARSE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_sparse_t ecs_sparse_t;

FLECS_API ecs_sparse_t* _ecs_sparse_new(
    ecs_size_t elem_size);

FLECS_API void ecs_sparse_set_id_source(
    ecs_sparse_t *sparse,
    uint64_t *id_source);

#define ecs_sparse_new(type)\
    _ecs_sparse_new(sizeof(type))

FLECS_API void ecs_sparse_free(
    ecs_sparse_t *sparse);

FLECS_API void ecs_sparse_clear(
    ecs_sparse_t *sparse);

FLECS_API void* _ecs_sparse_add(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size);

#define ecs_sparse_add(sparse, type)\
    ((type*)_ecs_sparse_add(sparse, sizeof(type)))

FLECS_API uint64_t ecs_sparse_last_id(
    ecs_sparse_t *sparse);

FLECS_API uint64_t ecs_sparse_new_id(
    ecs_sparse_t *sparse);

FLECS_API const uint64_t* ecs_sparse_new_ids(
    ecs_sparse_t *sparse,
    int32_t count);

FLECS_API void ecs_sparse_remove(
    ecs_sparse_t *sparse,
    uint64_t index);

FLECS_API void* _ecs_sparse_remove_get(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t index);    

#define ecs_sparse_remove_get(sparse, type, index)\
    ((type*)_ecs_sparse_remove_get(sparse, sizeof(type), index))

FLECS_API void ecs_sparse_set_generation(
    ecs_sparse_t *sparse,
    uint64_t index);    

FLECS_API bool ecs_sparse_exists(
    ecs_sparse_t *sparse,
    uint64_t index);

FLECS_API void* _ecs_sparse_get(
    const ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t index);

#define ecs_sparse_get(sparse, type, index)\
    ((type*)_ecs_sparse_get(sparse, sizeof(type), index))

FLECS_API bool ecs_sparse_is_alive(
    const ecs_sparse_t *sparse,
    uint64_t index);

FLECS_API int32_t ecs_sparse_count(
    const ecs_sparse_t *sparse);

FLECS_API int32_t ecs_sparse_size(
    const ecs_sparse_t *sparse);

FLECS_API void* _ecs_sparse_get_sparse(
    const ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t index);

#define ecs_sparse_get_sparse(sparse, type, index)\
    ((type*)_ecs_sparse_get_sparse(sparse, sizeof(type), index))

FLECS_API void* _ecs_sparse_get_sparse_any(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t index);

#define ecs_sparse_get_sparse_any(sparse, type, index)\
    ((type*)_ecs_sparse_get_sparse_any(sparse, sizeof(type), index))

FLECS_API void* _ecs_sparse_get_or_create(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t index);

#define ecs_sparse_get_or_create(sparse, type, index)\
    ((type*)_ecs_sparse_get_or_create(sparse, sizeof(type), index))

FLECS_API void* _ecs_sparse_set(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    uint64_t index,
    void *value);

#define ecs_sparse_set(sparse, type, index, value)\
    ((type*)_ecs_sparse_set(sparse, sizeof(type), index, value))

FLECS_API const uint64_t* ecs_sparse_ids(
    const ecs_sparse_t *sparse);

FLECS_API void ecs_sparse_set_size(
    ecs_sparse_t *sparse,
    int32_t elem_count);

FLECS_API ecs_sparse_t* ecs_sparse_copy(
    const ecs_sparse_t *src);    

FLECS_API void ecs_sparse_restore(
    ecs_sparse_t *dst,
    const ecs_sparse_t *src);

FLECS_API void ecs_sparse_memory(
    ecs_sparse_t *sparse,
    int32_t *allocd,
    int32_t *used);


#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_MAP_H
#define FLECS_MAP_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_map_t ecs_map_t;
typedef struct ecs_bucket_t ecs_bucket_t;
typedef uint64_t ecs_map_key_t;

typedef struct ecs_map_iter_t {
    const ecs_map_t *map;
    ecs_bucket_t *bucket;
    int32_t bucket_index;
    int32_t element_index;
    void *payload;
} ecs_map_iter_t;

FLECS_API ecs_map_t * _ecs_map_new(
    ecs_size_t elem_size,
    ecs_size_t alignment, 
    int32_t elem_count);

#define ecs_map_new(T, elem_count)\
    _ecs_map_new(sizeof(T), ECS_ALIGNOF(T), elem_count)

FLECS_API void * _ecs_map_get(
    const ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key);

#define ecs_map_get(map, T, key)\
    (T*)_ecs_map_get(map, sizeof(T), (ecs_map_key_t)key)

FLECS_API void * _ecs_map_get_ptr(
    const ecs_map_t *map,
    ecs_map_key_t key);

#define ecs_map_get_ptr(map, T, key)\
    (T)_ecs_map_get_ptr(map, key)

FLECS_API void _ecs_map_set(
    ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key,
    const void *payload);

#define ecs_map_set(map, key, payload)\
    _ecs_map_set(map, sizeof(*payload), (ecs_map_key_t)key, payload);

FLECS_API void ecs_map_free(
    ecs_map_t *map);

FLECS_API void ecs_map_remove(
    ecs_map_t *map,
    ecs_map_key_t key);

FLECS_API void ecs_map_clear(
    ecs_map_t *map);

FLECS_API int32_t ecs_map_count(
    const ecs_map_t *map);

FLECS_API int32_t ecs_map_bucket_count(
    const ecs_map_t *map);

FLECS_API ecs_map_iter_t ecs_map_iter(
    const ecs_map_t *map);

FLECS_API void* _ecs_map_next(
    ecs_map_iter_t* iter,
    ecs_size_t elem_size,
    ecs_map_key_t *key);

#define ecs_map_next(iter, T, key) \
    (T*)_ecs_map_next(iter, sizeof(T), key)

FLECS_API void* _ecs_map_next_ptr(
    ecs_map_iter_t* iter,
    ecs_map_key_t *key);

#define ecs_map_next_ptr(iter, T, key) \
    (T)_ecs_map_next_ptr(iter, key)

FLECS_API void ecs_map_grow(
    ecs_map_t *map, 
    int32_t elem_count);

FLECS_API void ecs_map_set_size(
    ecs_map_t *map, 
    int32_t elem_count);

FLECS_API void ecs_map_memory(
    ecs_map_t *map, 
    int32_t *allocd,
    int32_t *used);

FLECS_API ecs_map_t* ecs_map_copy(
    const ecs_map_t *map);

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_PTREE_H
#define FLECS_PTREE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_ptree_t ecs_ptree_t;

FLECS_API ecs_ptree_t* _ecs_ptree_new(
    ecs_size_t elem_size);

FLECS_API uint32_t ecs_ptree_free(
    ecs_ptree_t *ptree);

FLECS_API void* _ecs_ptree_ensure(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

FLECS_API void* _ecs_ptree_get(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

#define ecs_ptree_new(T)\
    _ecs_ptree_new(ECS_SIZEOF(T))

#define ecs_ptree_get(ptree, T, index)\
    (T*)_ecs_ptree_get(ptree, ECS_SIZEOF(T), index)

#define ecs_ptree_ensure(ptree, T, index)\
    _ecs_ptree_ensure(ptree, ECS_SIZEOF(T), index)


/* -- Low footprint version, do not mix API calls -- */

FLECS_API ecs_ptree_t* _ecs_ptiny_new(
    ecs_size_t elem_size);

FLECS_API void* _ecs_ptiny_ensure(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

FLECS_API void* _ecs_ptiny_get(
    ecs_ptree_t *ptree,
    ecs_size_t elem_size,
    uint64_t index);

#define ecs_ptiny_new(T)\
    _ecs_ptiny_new(ECS_SIZEOF(T))

#define ecs_ptiny_get(ptree, T, index)\
    (T*)_ecs_ptiny_get(ptree, ECS_SIZEOF(T), index)

#define ecs_ptiny_ensure(ptree, T, index)\
    _ecs_ptiny_ensure(ptree, ECS_SIZEOF(T), index)

#define ecs_ptiny_free(ptree)\
    ecs_ptree_free(ptree)

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_OS_API_H
#define FLECS_OS_API_H

#include <stdarg.h>

#if defined(_MSC_VER) || defined(__MINGW32__)
#include <malloc.h>
#elif defined(__FreeBSD__)
#include <stdlib.h>
#else
#include <alloca.h>
#endif

#if defined(_WIN32)
#define ECS_OS_WINDOWS
#elif defined(__linux__)
#define ECS_OS_LINUX
#elif defined(__APPLE__) && defined(__MACH__)
#define ECS_OS_DARWIN
#else
/* Unknown OS */
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_time_t {
    uint32_t sec;
    uint32_t nanosec;
} ecs_time_t;

/* Allocation counters (not thread safe) */
extern int64_t ecs_os_api_malloc_count;
extern int64_t ecs_os_api_realloc_count;
extern int64_t ecs_os_api_calloc_count;
extern int64_t ecs_os_api_free_count;

/* Use handle types that _at least_ can store pointers */
typedef uintptr_t ecs_os_thread_t;
typedef uintptr_t ecs_os_cond_t;
typedef uintptr_t ecs_os_mutex_t;
typedef uintptr_t ecs_os_dl_t;

/* Generic function pointer type */
typedef void (*ecs_os_proc_t)(void);

/* OS API init */
typedef 
void (*ecs_os_api_init_t)(void);

/* OS API deinit */
typedef 
void (*ecs_os_api_fini_t)(void);

/* Memory management */
typedef 
void* (*ecs_os_api_malloc_t)(
    ecs_size_t size);

typedef 
void (*ecs_os_api_free_t)(
    void *ptr);

typedef
void* (*ecs_os_api_realloc_t)(
    void *ptr, 
    ecs_size_t size);

typedef
void* (*ecs_os_api_calloc_t)(
    ecs_size_t size);

typedef
char* (*ecs_os_api_strdup_t)(
    const char *str);

/* Threads */
typedef
void* (*ecs_os_thread_callback_t)(
    void*);

typedef
ecs_os_thread_t (*ecs_os_api_thread_new_t)(
    ecs_os_thread_callback_t callback,
    void *param);

typedef
void* (*ecs_os_api_thread_join_t)(
    ecs_os_thread_t thread);


/* Atomic increment / decrement */
typedef
int (*ecs_os_api_ainc_t)(
    int32_t *value);


/* Mutex */
typedef
ecs_os_mutex_t (*ecs_os_api_mutex_new_t)(
    void);

typedef
void (*ecs_os_api_mutex_lock_t)(
    ecs_os_mutex_t mutex);

typedef
void (*ecs_os_api_mutex_unlock_t)(
    ecs_os_mutex_t mutex);

typedef
void (*ecs_os_api_mutex_free_t)(
    ecs_os_mutex_t mutex);

/* Condition variable */
typedef
ecs_os_cond_t (*ecs_os_api_cond_new_t)(
    void);

typedef
void (*ecs_os_api_cond_free_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_signal_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_broadcast_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_wait_t)(
    ecs_os_cond_t cond,
    ecs_os_mutex_t mutex);

typedef 
void (*ecs_os_api_sleep_t)(
    int32_t sec,
    int32_t nanosec);

typedef
void (*ecs_os_api_get_time_t)(
    ecs_time_t *time_out);

/* Logging */
typedef
void (*ecs_os_api_log_t)(
    const char *fmt,
    va_list args);

/* Application termination */
typedef
void (*ecs_os_api_abort_t)(
    void);

/* Dynamic libraries */
typedef
ecs_os_dl_t (*ecs_os_api_dlopen_t)(
    const char *libname);

typedef
ecs_os_proc_t (*ecs_os_api_dlproc_t)(
    ecs_os_dl_t lib,
    const char *procname);

typedef
void (*ecs_os_api_dlclose_t)(
    ecs_os_dl_t lib);

typedef
char* (*ecs_os_api_module_to_path_t)(
    const char *module_id);

/* Prefix members of struct with 'ecs_' as some system headers may define 
 * macro's for functions like "strdup", "log" or "_free" */

typedef struct ecs_os_api_t {
    /* API init / deinit */
    ecs_os_api_init_t init_;
    ecs_os_api_fini_t fini_;

    /* Memory management */
    ecs_os_api_malloc_t malloc_;
    ecs_os_api_realloc_t realloc_;
    ecs_os_api_calloc_t calloc_;
    ecs_os_api_free_t free_;

    /* Strings */
    ecs_os_api_strdup_t strdup_;

    /* Threads */
    ecs_os_api_thread_new_t thread_new_;
    ecs_os_api_thread_join_t thread_join_;

    /* Atomic incremenet / decrement */
    ecs_os_api_ainc_t ainc_;
    ecs_os_api_ainc_t adec_;

    /* Mutex */
    ecs_os_api_mutex_new_t mutex_new_;
    ecs_os_api_mutex_free_t mutex_free_;
    ecs_os_api_mutex_lock_t mutex_lock_;
    ecs_os_api_mutex_lock_t mutex_unlock_;

    /* Condition variable */
    ecs_os_api_cond_new_t cond_new_;
    ecs_os_api_cond_free_t cond_free_;
    ecs_os_api_cond_signal_t cond_signal_;
    ecs_os_api_cond_broadcast_t cond_broadcast_;
    ecs_os_api_cond_wait_t cond_wait_;

    /* Time */
    ecs_os_api_sleep_t sleep_;
    ecs_os_api_get_time_t get_time_;

    /* Logging */
    ecs_os_api_log_t log_;
    ecs_os_api_log_t log_error_;
    ecs_os_api_log_t log_debug_;
    ecs_os_api_log_t log_warning_;

    /* Application termination */
    ecs_os_api_abort_t abort_;

    /* Dynamic library loading */
    ecs_os_api_dlopen_t dlopen_;
    ecs_os_api_dlproc_t dlproc_;
    ecs_os_api_dlclose_t dlclose_;

    /* Overridable function that translates from a logical module id to a
     * shared library filename */
    ecs_os_api_module_to_path_t module_to_dl_;

    /* Overridable function that translates from a logical module id to a
     * path that contains module-specif resources or assets */
    ecs_os_api_module_to_path_t module_to_etc_;    
} ecs_os_api_t;

FLECS_API
extern ecs_os_api_t ecs_os_api;

FLECS_API
void ecs_os_init(void);

FLECS_API
void ecs_os_fini(void);

FLECS_API
void ecs_os_set_api(
    ecs_os_api_t *os_api);

FLECS_API
void ecs_os_set_api_defaults(void);

/* Memory management */
#define ecs_os_malloc(size) ecs_os_api.malloc_(size);
#define ecs_os_free(ptr) ecs_os_api.free_(ptr);
#define ecs_os_realloc(ptr, size) ecs_os_api.realloc_(ptr, size)
#define ecs_os_calloc(size) ecs_os_api.calloc_(size)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define ecs_os_alloca(size) _alloca((size_t)(size))
#else
#define ecs_os_alloca(size) alloca((size_t)(size))
#endif

/* Strings */
#define ecs_os_strdup(str) ecs_os_api.strdup_(str)
#define ecs_os_strlen(str) (ecs_size_t)strlen(str)
#define ecs_os_strcmp(str1, str2) strcmp(str1, str2)
#define ecs_os_strncmp(str1, str2, num) strncmp(str1, str2, (size_t)(num))
#define ecs_os_memcmp(ptr1, ptr2, num) memcmp(ptr1, ptr2, (size_t)(num))
#define ecs_os_memcpy(ptr1, ptr2, num) memcpy(ptr1, ptr2, (size_t)(num))
#define ecs_os_memset(ptr, value, num) memset(ptr, value, (size_t)(num))

#if defined(_MSC_VER)
#define ecs_os_strcat(str1, str2) strcat_s(str1, INT_MAX, str2)
#define ecs_os_sprintf(ptr, ...) sprintf_s(ptr, INT_MAX, __VA_ARGS__)
#define ecs_os_vsprintf(ptr, fmt, args) vsprintf_s(ptr, INT_MAX, fmt, args)
#define ecs_os_strcpy(str1, str2) strcpy_s(str1, INT_MAX, str2)
#define ecs_os_strncpy(str1, str2, num) strncpy_s(str1, INT_MAX, str2, (size_t)(num))
#else
#define ecs_os_strcat(str1, str2) strcat(str1, str2)
#define ecs_os_sprintf(ptr, ...) sprintf(ptr, __VA_ARGS__)
#define ecs_os_vsprintf(ptr, fmt, args) vsprintf(ptr, fmt, args)
#define ecs_os_strcpy(str1, str2) strcpy(str1, str2)
#define ecs_os_strncpy(str1, str2, num) strncpy(str1, str2, (size_t)(num))
#endif


/* Threads */
#define ecs_os_thread_new(callback, param) ecs_os_api.thread_new_(callback, param)
#define ecs_os_thread_join(thread) ecs_os_api.thread_join_(thread)

/* Atomic increment / decrement */
#define ecs_os_ainc(value) ecs_os_api.ainc_(value)
#define ecs_os_adec(value) ecs_os_api.adec_(value)

/* Mutex */
#define ecs_os_mutex_new() ecs_os_api.mutex_new_()
#define ecs_os_mutex_free(mutex) ecs_os_api.mutex_free_(mutex)
#define ecs_os_mutex_lock(mutex) ecs_os_api.mutex_lock_(mutex)
#define ecs_os_mutex_unlock(mutex) ecs_os_api.mutex_unlock_(mutex)

/* Condition variable */
#define ecs_os_cond_new() ecs_os_api.cond_new_()
#define ecs_os_cond_free(cond) ecs_os_api.cond_free_(cond)
#define ecs_os_cond_signal(cond) ecs_os_api.cond_signal_(cond)
#define ecs_os_cond_broadcast(cond) ecs_os_api.cond_broadcast_(cond)
#define ecs_os_cond_wait(cond, mutex) ecs_os_api.cond_wait_(cond, mutex)

/* Time */
#define ecs_os_sleep(sec, nanosec) ecs_os_api.sleep_(sec, nanosec)
#define ecs_os_get_time(time_out) ecs_os_api.get_time_(time_out)

/* Logging (use functions to avoid using variadic macro arguments) */
FLECS_API
void ecs_os_log(const char *fmt, ...);

FLECS_API
void ecs_os_warn(const char *fmt, ...);

FLECS_API
void ecs_os_err(const char *fmt, ...);

FLECS_API
void ecs_os_dbg(const char *fmt, ...);

/* Application termination */
#define ecs_os_abort() ecs_os_api.abort_()

/* Dynamic libraries */
#define ecs_os_dlopen(libname) ecs_os_api.dlopen_(libname)
#define ecs_os_dlproc(lib, procname) ecs_os_api.dlproc_(lib, procname)
#define ecs_os_dlclose(lib) ecs_os_api.dlclose_(lib)

/* Module id translation */
#define ecs_os_module_to_dl(lib) ecs_os_api.module_to_dl_(lib)
#define ecs_os_module_to_etc(lib) ecs_os_api.module_to_etc_(lib)

/* Sleep with floating point time */
FLECS_API
void ecs_sleepf(
    double t);

/* Measure time since provided timestamp */
FLECS_API
double ecs_time_measure(
    ecs_time_t *start);

/* Calculate difference between two timestamps */
FLECS_API
ecs_time_t ecs_time_sub(
    ecs_time_t t1,
    ecs_time_t t2);

/* Convert time value to a double */
FLECS_API
double ecs_time_to_double(
    ecs_time_t t);

FLECS_API
void* ecs_os_memdup(
    const void *src, 
    ecs_size_t size);

/** Are heap functions available? */
FLECS_API
bool ecs_os_has_heap(void);

/** Are threading functions available? */
FLECS_API
bool ecs_os_has_threading(void);

/** Are time functions available? */
FLECS_API
bool ecs_os_has_time(void);

/** Are logging functions available? */
FLECS_API
bool ecs_os_has_logging(void);

/** Are dynamic library functions available? */
FLECS_API
bool ecs_os_has_dl(void);

/** Are module path functions available? */
FLECS_API
bool ecs_os_has_modules(void);

#ifdef __cplusplus
}
#endif

#endif
/**
 * @file api_defines.h
 * @brief Supporting types for the public API.
 *
 * This file containstypes that are typically not used by an application but 
 * support the public API, and therefore must be exposed. This header should not
 * be included by itself.
 */

#ifndef FLECS_API_TYPES_H
#define FLECS_API_TYPES_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Opaque types
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_table_t ecs_table_t;


////////////////////////////////////////////////////////////////////////////////
//// Non-opaque types
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_record_t {
    ecs_table_t *table;  /* Identifies a type (and table) in world */
    int32_t row;         /* Table row of the entity */
} ecs_record_t;

/** Array of entity ids that, other than a type, can live on the stack */
typedef struct ecs_entities_t {
    ecs_entity_t *array;    /**< An array with entity ids */
    int32_t count;          /**< The number of entities in the array */
} ecs_entities_t;

typedef struct ecs_world_info_t {
    ecs_entity_t last_component_id;   /**< Last issued component entity id */
    ecs_entity_t last_id;             /**< Last issued entity id */
} ecs_world_info_t;


////////////////////////////////////////////////////////////////////////////////
//// Function types
////////////////////////////////////////////////////////////////////////////////

/** Constructor/destructor. Used for initializing / deinitializing components. */
typedef void (*ecs_xtor_t)(
    void *ptr,
    size_t size,
    int32_t count);

/** Copy is invoked when a component is copied into another component. */
typedef void (*ecs_copy_t)(
    void *dst_ptr,
    const void *src_ptr,
    size_t size,
    int32_t count);

/** Move is invoked when a component is moved to another component. */
typedef void (*ecs_move_t)(
    void *dst_ptr,
    void *src_ptr,
    size_t size,
    int32_t count);

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_LOG_H
#define FLECS_LOG_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Color macro's
////////////////////////////////////////////////////////////////////////////////

#define ECS_BLACK   "\033[1;30m"
#define ECS_RED     "\033[0;31m"
#define ECS_GREEN   "\033[0;32m"
#define ECS_YELLOW  "\033[0;33m"
#define ECS_BLUE    "\033[0;34m"
#define ECS_MAGENTA "\033[0;35m"
#define ECS_CYAN    "\033[0;36m"
#define ECS_WHITE   "\033[1;37m"
#define ECS_GREY    "\033[0;37m"
#define ECS_NORMAL  "\033[0;49m"
#define ECS_BOLD    "\033[1;49m"


////////////////////////////////////////////////////////////////////////////////
//// Tracing
////////////////////////////////////////////////////////////////////////////////

FLECS_API void _ecs_trace(
    int level,
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_API void _ecs_warn(
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_API void _ecs_err(
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_API void ecs_log_push(void);

FLECS_API void ecs_log_pop(void);

#ifndef FLECS_LEGACY

#define ecs_trace(lvl, ...)\
    _ecs_trace(lvl, __FILE__, __LINE__, __VA_ARGS__)

#define ecs_warn(...)\
    _ecs_warn(__FILE__, __LINE__, __VA_ARGS__)

#define ecs_err(...)\
    _ecs_err(__FILE__, __LINE__, __VA_ARGS__)


/* If in debug mode and no tracing verbosity is defined, compile all tracing */
#if !defined(NDEBUG) && !(defined(ECS_TRACE_0) || defined(ECS_TRACE_1) || defined(ECS_TRACE_2) || defined(ECS_TRACE_3))
#define ECS_TRACE_3
#endif

#ifndef NDEBUG
#if defined(ECS_TRACE_3)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...) ecs_trace(3, __VA_ARGS__);

#elif defined(ECS_TRACE_2)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...)

#elif defined(ECS_TRACE_1)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif
#else
#define ecs_trace_1(...)
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif
#endif

////////////////////////////////////////////////////////////////////////////////
//// Exceptions
////////////////////////////////////////////////////////////////////////////////

/** Get description for error code */
FLECS_API const char* ecs_strerror(
    int32_t error_code);

/** Abort */
FLECS_API void _ecs_abort(
    int32_t error_code,
    const char *file,
    int32_t line);

#define ecs_abort(error_code)\
    _ecs_abort(error_code, __FILE__, __LINE__); abort()

/** Assert */
FLECS_API void _ecs_assert(
    bool condition,
    int32_t error_code,
    const char *condition_str,
    const char *file,
    int32_t line);

#ifdef NDEBUG
#define ecs_assert(condition, error_code)
#else
#define ecs_assert(condition, error_code)\
    _ecs_assert(condition, error_code, #condition, __FILE__, __LINE__);\
    assert(condition)
#endif

#ifdef __cplusplus
}
#endif

#endif
/**
 * @file type.h
 * @brief Type API.
 */

#ifndef FLECS_TYPE_H
#define FLECS_TYPE_H

typedef const ecs_vector_t* ecs_type_t;

#ifdef __cplusplus
extern "C" {
#endif

FLECS_API char* ecs_type_str(
    ecs_world_t *world,
    ecs_type_t type);    

FLECS_API bool ecs_type_has_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_API int32_t ecs_type_index_of(
    ecs_type_t type,
    ecs_entity_t component);

FLECS_API ecs_entity_t ecs_type_contains(
    ecs_world_t *world,
    ecs_type_t type_id_1,
    ecs_type_t type_id_2,
    bool match_all);

#ifdef __cplusplus
}
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct EcsName {
    const char *value;
    const char *symbol;
    char *alloc_value;
} EcsName;

typedef struct EcsComponent {
    ecs_size_t size;
    ecs_size_t alignment;
} EcsComponent;

typedef struct ecs_lifecycle_t {
    ecs_xtor_t ctor;
    ecs_xtor_t dtor;
    ecs_copy_t copy;
    ecs_move_t move;
    bool is_set;
} ecs_lifecycle_t;


/**
 * @defgroup world_api World API
 * @{
 */

FLECS_API ecs_world_t* ecs_init(void);

FLECS_API int ecs_fini(
    ecs_world_t *world);

FLECS_API void ecs_set_lifecycle(
    ecs_world_t *world,
    ecs_entity_t component,
    ecs_lifecycle_t *actions);

FLECS_API void ecs_dim(
    ecs_world_t *world,
    int32_t entity_count);

FLECS_API void ecs_defer_begin(
    ecs_world_t *world);

FLECS_API void ecs_defer_end(
    ecs_world_t *world);

FLECS_API void ecs_tracing_enable(
    int level);

/** @} */


/**
 * @defgroup basic Basic ECS operations
 * @{
 */

FLECS_API ecs_entity_t ecs_new_id(
    ecs_world_t *world);

FLECS_API ecs_entity_t ecs_new_component_id(
    ecs_world_t *world);

FLECS_API void ecs_add_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void ecs_remove_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void ecs_clear(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API void ecs_delete(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API const void* ecs_get_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API void* ecs_get_mut_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id,
    bool *is_added);

FLECS_API void ecs_modified_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API ecs_entity_t ecs_set_ptr_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id,
    const void *ptr,
    size_t size);

FLECS_API bool ecs_has_id(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t id);

FLECS_API bool ecs_is_alive(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API bool ecs_exists(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API ecs_type_t ecs_get_type(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_API const char* ecs_get_name(
    ecs_world_t *world,
    ecs_entity_t entity);

/** @} */


/**
 * @defgroup scopes Scoping
 * @{
 */

FLECS_API ecs_entity_t ecs_set_scope(
    ecs_world_t *world,
    ecs_entity_t scope);

FLECS_API ecs_entity_t ecs_get_scope(
    ecs_world_t *world);

/** @} */


/**
 * @defgroup macro_api Macro wrappers for type safety & convenience
 * @{
 */

#define ECS_ROLE ((uint64_t)1 << 63)

#define ecs_role(role, id) (ECS_ROLE | ((uint64_t)role << 32) | (uint32_t)id)

#define ecs_get_role(id) ((id & ~ECS_ROLE) >> 32)

#define ecs_has_role(role, id) (ecs_get_role(id) == role)

#define ecs_typeid(T) FLECS__E##T


#ifndef FLECS_LEGACY

#define ecs_has(world, entity, type)\
    (ecs_has_id(world, entity, ecs_typeid(type)))

#define ecs_get(world, entity, type)\
    ((const type*)ecs_get_id(world, entity, ecs_typeid(type)))

#define ecs_get_mut(world, entity, type, is_added)\
    ((type*)ecs_get_mut_id(world, entity, ecs_typeid(type), is_added))

#define ecs_set(world, entity, type, ...)\
    (ecs_set_ptr_id(world, entity, ecs_typeid(type), &(type)__VA_ARGS__, sizeof(type)))

#endif

/** @} */ 


#ifdef __cplusplus
}
#endif

#endif
